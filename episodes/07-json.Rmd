---
title: Processing JSON data (Optional)
teaching: 30
exercises: 15
source: Rmd
editor_options: 
  markdown: 
    wrap: 72
---

:::: instructor

-   This is an optional lessons intended to introduce learners to JSON
    data, as well as how to read JSON data into R and how to convert the
    data into a data frame or array.
    
::::::::::::

::::::::::::::::::::::::::::::::::::::: objectives

-   Describe the JSON data format
-   Understand where JSON is typically used
-   Appreciate some advantages of using JSON over tabular data
-   Appreciate some disadvantages of processing JSON documents
-   Use the jsonLite package to read a JSON file
-   Display formatted JSON as data frame
-   Select and display nested data frame fields from a JSON document
-   Write tabular data from selected elements from a JSON document to a
    csv file
    
::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::: questions

-   What is JSON format?
-   How can I convert JSON to an R data frame?
-   How can I convert an array of JSON record into a table?

::::::::::::::::::::::::::::::::::::::::::::::::::

## The JSON Data Format

The JavaScript Object Notation, or JSON, is a text-based data format designed to 
allow different machines to process or communicate data with each other. JSON data 
instances, called "documents", are made up of key-value pairs (the equivalent of 
column names and their corresponding values). Unlike CSVs, or other tabular data, 
however, each JSON document is self-contained and does not require a consistent
structure. This means that each document can have unique fields, or, for fields 
that are shared across documents, can contain different data types.

The data is also human-readable, making it simple to understand, edit, and debug. 
As a result, JSON is now the preferred data format used by Application Programming 
Interfaces (APIs) and, more importantly for this lesson, can be mapped very easily 
to an R data frame!

Throughout this lesson, we are going to learn to read JSON-formatted data file, 
convert it into a data frame in R, and selectively create a CSV file from the 
extracted data (since JSON can be more difficult to process and display).

For this, we will be using `checkin_snippet.json`, a JSON-formatted fictional data 
set based on the Check-In Dataset.

## Reading and Converting JSON Files

To read JSON files, we will be using the **`jsonlite`** package (alongside the 
**`tidyverse`**, **`here`**, and **`lubridate`**). Let's load in all of our required 
packages below:
```{r load-packages, message=FALSE}
library(jsonlite)
library(tidyverse)
library(here)
library(lubridate)
```

While both **`readr`** (from the **`tidyverse`**) and **`jsonlite`** provide a 
function to read JSON files, each function has its own strengths and weaknesses 
depending on the structure of the JSON file:

1. **`read_json()`** (from **`readr`**) initially keeps the raw JSON structure 
as a list, giving you full control over how the JSON file is converted into a 
data frame. This is better for extremely nested or inconsistent JSON files, as 
auto-conversion to a data frame may make mistakes. However, since it does not 
convert manually, converting to a data frame/CSV file requires more steps.

2. **`fromJSON()`** (from **`jsonlite`**) automatically parses JSON files into 
data frames, allowing for quick, simple data analysis. This is better for structured 
JSON files, as the chance of mistakes occurring during conversion is lower. However, 
since it automatically converts to a data frame, you have little to no control over 
how the JSON is initially converted.

Throughout this lesson, we will be explaining how to complete each each using *both*
functions! However, in practice, ensure you choose the appropriate function for 
the JSON data you are working with. 

### `read_json()`

Let's begin by using the **`read_json()`** function to import our data into R:
```{r readr-import, eval=FALSE}
readr_data <- read_json(here("episodes", "data", "checkin_snippet.json"))
```

After running this code, we can see that a new List object called readr_data has 
appeared in our Environment! Let's take a look at what this object looks like 
using the `head(x, 1)` function:
```{r readr-view, eval=FALSE}
head(readr_data, 1)
```

As we can see, this object is near-identical to the format of our `checkin_snippet.json` 
file! To convert this list into a data frame, we will be using the `map_dfr()` function. 
This function iterates over every element in a list, applies a function, and combines 
the results into a data fame.

In our case, we are going through each element of readr_data, manually setting each 
column of a tibble to each key-value pair in the JSON file, and adding each tibble 
as a row of our larger, `readr_data` data frame! We will be using `tibble()` instead 
of `data_frame()` because handles list-columns much safer:
```{r readr-df, eval=FALSE}
readr_data <- map_dfr(readr_data, function(x) {
  tibble(
    precinct_id = x$precinct_id,
    polling_place = x$polling_place,
    scanner_id = x$scanner_id,
    arrival_summary = list(x$arrival_summary)
  )
})

head(readr_data)
```

After using the `map_dfr()` function, our data is now in a long format, with the 
nested `arrival_summary` column including both the integer `total_arrivals` field 
*and* character `first_arrival` and `last_arrival` fields. We can fix this applying 
`unnest_wider()` to the `arrival_summary` column! 

The `unnest_wider()` does the *exact same thing* as the `pivot_wider()` function 
EXCEPT it works with already named lists (ie. does not need us to specify the names 
of the lists):
```{r readr-pivot, eval=FALSE}
readr_data <- readr_data %>%
  unnest_wider(arrival_summary)

head(readr_data)
```

As you may notice, the `first_arrival` and `last_arrival` columns contain dates! 
Thus, as our final step, we will be converting each of these columns to `ymd_hms`
format instead:
```{r readr-convert-2, eval=FALSE}
readr_data <- readr_data %>%
  mutate(
    first_arrival = ymd_hms(first_arrival),
    last_arrival = ymd_hms(last_arrival)
  )

head(readr_data)
```

Congratulations! We've finally converted our JSON data into a properly formatted 
data frame.

Notably, **`read_json()`** has a `simplifyVector = TRUE` argument, which completes 
a few of these steps for you! Let's re-read in our data, including this argument, 
below:
```{r readr-import-2, eval=FALSE}
readr_data_2 <- read_json(here("episodes", "data", "checkin_snippet.json"), simplifyVector = TRUE)

head(readr_data_2)
```

As you can see, this creates a data frame, with an `arrival_summary` column that 
includes a data frame within it. Below, we'll be completing all of the steps above, 
but on the `readr_data_2` object instead:

```{r readr-convert-2, eval=FALSE}
readr_data_2 <- readr_data_2 %>%
  unnest_wider(arrival_summary) %>%
  mutate(
    first_arrival = ymd_hms(first_arrival),
    last_arrival = ymd_hms(last_arrival)
  )

head(readr_data_2)
```

As you can see, `readr_data_2` is identical to `readr_data`! In practice, however, 
we DO NOT recommend using the `simplifyVector = TRUE` argument, as it completely
nullifies the control **`read_json()`** gives over the conversion from JSON to 
data frame and has the same issues as **`fromJSON()`** when dealing with extremely 
nested or inconsistent JSON files.

### `fromJSON()`

Let's begin by using the **`fromJSON()`** function to import our data into R:
```{r json-import, eval=FALSE}
json_data <- fromJSON(here("episodes", "data", "checkin_snippet.json"))

head(json_data)
```

As you may notice, this is *identical* to the result of running `readr_data_2 <- read_json(here( "data", "checkin_snippet.json"), simplifyVector = TRUE)`. Thus, we can apply the same 
steps when converting to a formatted data frame:

```{r json-convert, eval=FALSE}
json_data <- json_data %>%
  unnest_wider(arrival_summary) %>%
  mutate(
    first_arrival = ymd_hms(first_arrival),
    last_arrival = ymd_hms(last_arrival)
  )


head(json_data)
```

We'd like to note that the **`fromJSON()`** function includes a `flatten = TRUE` 
argument that completes the unnest_wider() step for you! Below, let's import our 
data using this argument:
```{r json-import-2, eval=FALSE}
json_data_2 <- fromJSON(here("episodes", "data", "checkin_snippet.json"), flatten = TRUE)

head(json_data_2)
```

As you can see, the only additional steps we need to take is renaming the columns 
and converting the `first_arrival` and `last_arrival` columns to datetime format!
We can do so below:
```{r json-convert-2, eval=FALSE}
json_data_2 <- json_data_2 %>%
  rename(
    total_arrivals = arrival_summary.total_arrivals,
    first_arrival = arrival_summary.first_arrival,
    last_arrival = arrival_summary.last_arrival
  ) %>%
  mutate(
    first_arrival = ymd_hms(first_arrival),
    last_arrival = ymd_hms(last_arrival)
  )

head(json_data_2)
```

## Writing JSON to CSV

Now that we've converted our JSON file into a properly formatted data frame using 
both functions, let's write our file to a CSV! To do so, we will use the `write_csv()`
function that we've used throughout our previous lessons.

Here, we can finally export our `readr_data` data frame to a `voter_arrivals.csv` 
file:
```{r, eval=FALSE}
write_csv(readr_data, "data/voter_arrivals.csv")
```

:::::::::::::::::::::::::::::::::::::::::  callout

## Note

When reading your CSV back into R, your `first_arrival` and `last_arrival` columns
will again be read in as characters/strings instead of dates. If you are ONLY formatting 
a JSON into a CSV without additional analysis, you can technically skip the part 
where you convert the columns into dates. 
However, we recommend converting columns into proper data types to ensure if you 
choose to complete analysis, you can do so!

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::: keypoints

-   Understand what a JSON document is and what it's most common use cases are.
-   Convert a JSON into a properly formatted data frame.
-   Output a JSON file to a CSV file.

::::::::::::::::::::::::::::::::::::::::::::::::::
