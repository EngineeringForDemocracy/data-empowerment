---
title: Data Visualisation with ggplot2
teaching: 80
exercises: 35
source: Rmd
---

```{r setup, include=FALSE}
# We will be using the anonymized check-in data from a previous episode.
```

:::: instructor

- This episode is a broad overview of ggplot2 and focuses on (1) getting
  familiar with the layering system of ggplot2, (2) using the argument `group`
  in the `aes()` function, (3) basic customization of the plots.
- The data we're using is an anonymized check-in dataset containing timestamps, 
  locations, precincts, and device information.
- We'll show how to visualize patterns in check-in behavior across different 
  locations and devices, and introduce mapping techniques.

::::::::::::

::::::::::::::::::::::::::::::::::::::: objectives

- Produce scatter plots, boxplots, and barplots using ggplot.
- Create time series plots for temporal check-in data.
- Set universal plot settings.
- Describe what faceting is and apply faceting in ggplot.
- Modify the aesthetics of an existing ggplot plot (including axis labels and colour).
- Build complex and customized plots from data in a data frame.
- Create maps with ggplot2 to visualize location-based data.
- Recognize the differences between base R, lattice, and ggplot visualizations.

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::: questions

- What are the components of a ggplot?
- How can I visualize check-in patterns over time?
- How can I compare check-in frequencies across locations and devices?
- What are the main differences between R base plots, lattice, and ggplot?
- How can I visualize location data on maps with ggplot2?

::::::::::::::::::::::::::::::::::::::::::::::::::

We start by loading the required packages. **`ggplot2`** is included in the
**`tidyverse`** package.

```{r load-package, message=FALSE, purl=FALSE}
library(tidyverse)
library(lubridate) # For working with date-time data
```

Now let's load our check-in data:

```{r load-data, purl=FALSE}
checkins <- read_csv("data/anonymized_data.csv")
```

Let's first examine our data structure:

```{r examine-data}
glimpse(checkins)
```

To work effectively with the timestamps, we need to convert the `checkin_time` column to a proper datetime format:

```{r process-data}
checkins <- sample_n(checkins, 500) %>%
  mutate(
    checkin_time = ymd_hms(checkin_time),
    checkin_date = as.Date(checkin_time),
    checkin_hour = hour(checkin_time),
    checkin_minute = minute(checkin_time)
  )
```

## Visualization Options in R

Before we start with **`ggplot2`**, it's helpful to know that there are several ways to create visualizations in R. While **`ggplot2`** is great for building complex and highly customizable plots, there are simpler and quicker alternatives that you might encounter or use depending on the context. Let's briefly explore a few of them:

### R Base Plots
Base R plots are the simplest form of visualization and are great for quick, exploratory analysis. You can create plots with very little code, but customizing them can be cumbersome compared to **`ggplot2`**.

Example of a simple time series plot in base R showing check-ins by hour:

```{r, purl=FALSE}
hourly_counts <- sample_n(checkins, 500) %>%
  count(checkin_hour)

plot(hourly_counts$checkin_hour, hourly_counts$n,
     main = "Base R Plot: Check-ins by Hour",
     xlab = "Hour of Day",
     ylab = "Number of Check-ins",
     type = "l")  # 'l' for line
```

### **`Lattice`**
Lattice is another plotting system in R, which allows for creating multi-panel plots easily. It's different from ggplot2 because you define the entire plot in a single function call, and modifications after plotting are limited.

Example of a lattice plot showing check-ins by device for different locations:

```{r lattice, message=FALSE, purl=FALSE}
library(lattice)
```
```{r, purl=FALSE}
# Convert device to factor to avoid coercion warnings
checkins_lattice <- sample_n(checkins, 500) %>%
  mutate(device = as.factor(device), 
         location = as.factor(location))

# Create a proper lattice plot with categorical variables
xyplot(checkin_hour ~ as.integer(device) | location, data = checkins_lattice,
       main = "Lattice Plot: Check-in Hour by Device and Location",
       xlab = "Device",
       ylab = "Hour of Check-in",
       strip = strip.custom(bg="lightgrey"),
       panel = function(x, y, ...) {
         panel.xyplot(x, y, ...)
         panel.loess(x, y, col="red", lwd=2)
       })
```

## Plotting with **`ggplot2`**

**`ggplot2`** is a plotting package that makes it simple to create complex plots
from data stored in a data frame. It provides a programmatic interface for
specifying what variables to plot, how they are displayed, and general visual
properties. Therefore, we only need minimal changes if the underlying data
change or if we decide to change from a bar plot to a scatterplot. This helps in
creating publication quality plots with minimal amounts of adjustments and
tweaking.

**`ggplot2`** functions work best with data in the 'long' format, i.e., a column for every
dimension, and a row for every observation. Well-structured data will save you
lots of time when making figures with **`ggplot2`**

ggplot graphics are built step by step by adding new elements. Adding layers in
this fashion allows for extensive flexibility and customization of plots.

Each chart built with ggplot2 must include the following

- Data

- Aesthetic mapping (aes)
  
  - Describes how variables are mapped onto graphical attributes
  - Visual attribute of data including x-y axes, color, fill, shape, and alpha

- Geometric objects (geom)
  
  - Determines how values are rendered graphically, as bars (`geom_bar`), scatterplot (`geom_point`), line (`geom_line`), etc.

Thus, the template for graphic in ggplot2 is:

```
<DATA> %>%
    ggplot(aes(<MAPPINGS>)) +
    <GEOM_FUNCTION>()
```

Remember that the pipe operator `%>%` places the result of the previous line(s) into the first argument of the function. **`ggplot`** is a function that expects a data frame to be the first argument. This allows for us to change from specifying the `data =` argument within the `ggplot` function and instead pipe the data into the function.

- use the `ggplot()` function and bind the plot to a specific data frame.

```{r ggplot-steps-1, eval=FALSE, purl=FALSE}
sample_n(checkins, 500) %>%
  ggplot()
```

- define a mapping (using the aesthetic (`aes`) function), by selecting the variables to be plotted and specifying how to present them in the graph, e.g. as x/y positions or characteristics such as size, shape, color, etc.

```{r ggplot-steps-2, eval=FALSE, purl=FALSE}
sample_n(checkins, 500) %>%
  ggplot(aes(x = checkin_hour, y = precinct))
```

- add 'geoms' â€“ graphical representations of the data in the plot (points,
  lines, bars). **`ggplot2`** offers many different geoms; we will use some
  common ones today, including:
  
  - `geom_bar()` for counting observations in categories
  - `geom_histogram()` for showing distributions
  - `geom_boxplot()` for statistical summaries
  - `geom_line()` for trend lines, time series, etc.

To add a geom to the plot use the `+` operator. Let's start by creating a bar chart showing the distribution of check-ins across precincts:

```{r first-ggplot, purl=FALSE}
sample_n(checkins, 500) %>%
  ggplot(aes(x = precinct)) +
  geom_bar() +
  labs(title = "Number of Check-ins by Precinct",
       x = "Precinct",
       y = "Count")
```

The `+` in the **`ggplot2`** package is particularly useful because it allows
you to modify existing `ggplot` objects. This means you can easily set up plot
templates and conveniently explore different types of plots, so the above plot
can also be generated with code like this, similar to the "intermediate steps"
approach:

```{r first-ggplot-with-plus, fig.alt="Scatter plot of check-in hour versus precinct number.", eval=FALSE, purl=FALSE}
# Assign plot to a variable
checkins_plot <- sample_n(checkins, 500) %>%
  ggplot(aes(x = checkin_hour, y = precinct))

# Draw the plot as a dot plot
checkins_plot +
  geom_point()
```

:::::::::::::::::::::::::::::::::::::::::  callout

## Notes

- Anything you put in the `ggplot()` function can be seen by any geom layers
  that you add (i.e., these are universal plot settings). This includes the x-
  and y-axis mapping you set up in `aes()`.
- You can also specify mappings for a given geom independently of the mapping
  defined globally in the `ggplot()` function.
- The `+` sign used to add new layers must be placed at the end of the line
  containing the *previous* layer. If, instead, the `+` sign is added at the
  beginning of the line containing the new layer, **`ggplot2`** will not add
  the new layer and will return an error message.

::::::::::::::::::::::::::::::::::::::::::::::::::

```{r ggplot-with-plus-position, eval=FALSE, purl=FALSE}
## This is the correct syntax for adding layers
checkins_plot +
  geom_point()

## This will not add the new layer and will return an error message
checkins_plot
+ geom_point()
```

## Building your plots iteratively

Building plots with **`ggplot2`** is typically an iterative process. We start by
defining the dataset we'll use, lay out the axes, and choose a geom.

Let's create a time series plot showing the number of check-ins per hour:

```{r create-time-series, fig.alt="Time series plot showing check-ins by hour.", purl=FALSE}
# Group data by hour and count check-ins
hourly_data <- sample_n(checkins, 500) %>%
  count(checkin_hour)

# Create the time series plot
hourly_data %>%
  ggplot(aes(x = checkin_hour, y = n)) +
  geom_line() +
  geom_point()
```

Now let's improve this plot by adding better labels and a title:

```{r improve-time-series, fig.alt="Time series plot showing check-ins by hour with title and better labels.", purl=FALSE}
hourly_data %>%
  ggplot(aes(x = checkin_hour, y = n)) +
  geom_line() +
  geom_point() +
  labs(
    title = "Check-ins by Hour of Day",
    x = "Hour (24-hour format)",
    y = "Number of Check-ins"
  )
```

We can also look at the distribution of check-ins by location using a jitter plot:

```{r location-distribution, fig.alt="Scatter plot showing check-in hour distribution by location.", purl=FALSE}
sample_n(checkins, 500) %>%
  ggplot(aes(x = location, y = checkin_hour)) +
  geom_jitter(alpha = 0.5, width = 0.2, height = 0.1) +
  labs(
    title = "Distribution of Check-in Hours by Location",
    x = "Location",
    y = "Hour of Check-in"
  )
```

Adding transparency with `alpha` helps us see where points are overlapping. We can add color based on the device used:

```{r adding-colors, fig.alt="Scatter plot of check-in hour distribution by location, colored by device.", purl=FALSE}
sample_n(checkins, 500) %>%
  ggplot(aes(x = location, y = checkin_hour)) +
  geom_jitter(aes(color = device), alpha = 0.5, width = 0.2, height = 0.1) +
  labs(
    title = "Distribution of Check-in Hours by Location and Device",
    x = "Location",
    y = "Hour of Check-in"
  )
```

:::::::::::::::::::::::::::::::::::::::::  callout

## Notes

When you have overlapping points like in our time data, another useful way to visualize the data is with a count plot, where the size of points represents frequencies:

```{r color-by-species-notes, fig.alt="Count plot of check-in hour by location, with point size showing frequency.", purl=FALSE}
sample_n(checkins, 500) %>%
  ggplot(aes(x = location, y = checkin_hour, color = device)) +
  geom_count()
```

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::  challenge

## Exercise

Use what you just learned to create a scatter plot of `checkin_minute` by `location`
with the `device` showing in different colours. Does this give you any insights about check-in patterns?

:::::::::::::::  solution

## Solution

```{r scatter-challenge, fig.alt="Scatter plot showing check-in minutes by location colored by device.", answer=TRUE, purl=FALSE}
sample_n(checkins, 500) %>%
  ggplot(aes(x = location, y = checkin_minute)) +
  geom_jitter(aes(color = device),
              alpha = 0.5,
              width = 0.2,
              height = 0.2) +
  labs(title = "Check-in Minutes by Location and Device",
       x = "Location",
       y = "Minute of Check-in")
```

This visualization can help us see if certain devices are used for check-ins at specific minutes within the hour at different locations.

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## Boxplot

We can use boxplots to visualize the distribution of check-in hours for each location:

```{r boxplot, fig.alt="Box plot of check-in hours by location.", purl=FALSE}
sample_n(checkins, 500) %>%
  ggplot(aes(x = location, y = checkin_hour)) +
  geom_boxplot() +
  labs(title = "Distribution of Check-in Hours by Location",
       x = "Location",
       y = "Hour of Check-in")
```

By adding points to a boxplot, we can have a better idea of the number of
measurements and of their distribution:

```{r boxplot-with-jitter, fig.alt="Box plot of check-in hours by location with individual data points overlaid.", purl=FALSE}
sample_n(checkins, 500) %>%
  ggplot(aes(x = location, y = checkin_hour)) +
  geom_boxplot(alpha = 0) +
  geom_jitter(alpha = 0.5,
              color = "tomato",
              width = 0.2,
              height = 0.2) +
  labs(title = "Distribution of Check-in Hours by Location",
       x = "Location",
       y = "Hour of Check-in")
```

Notice how the boxplot layer is behind the jitter layer? What do you need to
change in the code to put the boxplot layer in front of the jitter layer?

:::::::::::::::::::::::::::::::::::::::  challenge

## Exercise

Boxplots are useful summaries, but hide the *shape* of the distribution. For
example, if the distribution is bimodal, we would not see it in a
boxplot. An alternative to the boxplot is the violin plot, where the shape
(of the density of points) is drawn.

- Replace the box plot with a violin plot; see `geom_violin()`.

:::::::::::::::  solution

## Solution

```{r violin-plot}
sample_n(checkins, 500) %>%
  ggplot(aes(x = location, y = checkin_hour)) +
  geom_violin(alpha = 0) +
  geom_jitter(alpha = 0.5, color = "tomato") +
  labs(title = "Distribution of Check-in Hours by Location",
       x = "Location",
       y = "Hour of Check-in")
```

:::::::::::::::::::::::::

So far, we've looked at the distribution of check-in hours within locations. Try
making a new plot to explore the distribution of another variable within locations.

- Create a boxplot for `checkin_minute` for each location. Overlay the boxplot
  layer on a jitter layer to show actual measurements.

:::::::::::::::  solution

## Solution

```{r boxplot-exercise, fig.alt="Box plot of check-in minutes by location, with dot plot added as additional layer to show individual values."}
sample_n(checkins, 500) %>%
  ggplot(aes(x = location, y = checkin_minute)) +
  geom_boxplot(alpha = 0) +
  geom_jitter(alpha = 0.5, width = 0.2, height = 0.2) +
  labs(title = "Distribution of Check-in Minutes by Location",
       x = "Location",
       y = "Minute of Check-in")
```

:::::::::::::::::::::::::

- Add colour to the data points on your boxplot according to the device used.

:::::::::::::::  solution

## Solution

```{r boxplot-exercise-factor, fig.alt="Box plot of check-in minutes by location with points colored by device."}
sample_n(checkins, 500) %>%
  ggplot(aes(x = location, y = checkin_minute)) +
  geom_boxplot(alpha = 0) +
  geom_jitter(aes(color = device), alpha = 0.5, width = 0.2, height = 0.2) +
  labs(title = "Distribution of Check-in Minutes by Location and Device",
       x = "Location", 
       y = "Minute of Check-in")
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## Barplots

Barplots are also useful for visualizing categorical data. By default,
`geom_bar` accepts a variable for x, and plots the number of instances each
value of x (in this case, location) appears in the dataset.

```{r barplot-1, fig.alt="Bar plot showing counts of check-ins by location."}
sample_n(checkins, 500) %>%
  ggplot(aes(x = location)) +
  geom_bar() +
  labs(title = "Number of Check-ins by Location",
       x = "Location",
       y = "Count")
```

We can use the `fill` aesthetic for the `geom_bar()` geom to colour bars by
the device used for check-in.

```{r barplot-stack, fig.alt="Stacked bar plot of check-ins by location with each device as a different color."}
sample_n(checkins, 500) %>%
  ggplot(aes(x = location)) +
  geom_bar(aes(fill = device)) +
  labs(title = "Number of Check-ins by Location and Device",
       x = "Location",
       y = "Count")
```

This creates a stacked bar chart. These are generally more difficult to read
than side-by-side bars. We can separate the portions of the stacked bar that
correspond to each device and put them side-by-side by using the `position`
argument for `geom_bar()` and setting it to "dodge".

```{r barplot-dodge, fig.alt="Bar plot of check-ins by location with each device as a separate bar."}
sample_n(checkins, 500) %>%
  ggplot(aes(x = location)) +
  geom_bar(aes(fill = device), position = "dodge") +
  labs(title = "Number of Check-ins by Location and Device",
       x = "Location",
       y = "Count")
```

Let's also create a bar chart showing the number of check-ins by hour:

```{r barplot-hours, fig.alt="Bar plot showing number of check-ins by hour of day."}
sample_n(checkins, 500) %>%
  ggplot(aes(x = checkin_hour)) +
  geom_bar() +
  labs(title = "Number of Check-ins by Hour of Day",
       x = "Hour of Day",
       y = "Count")
```

We might want to analyze what percentage of check-ins come from each device at each location. Let's calculate this:

```{r percent-device-data}
percent_device <- sample_n(checkins, 500) %>%
  count(location, device) %>%
  group_by(location) %>%
  mutate(percent = (n / sum(n)) * 100) %>%
  ungroup()
```

Now we can create a plot showing the percentage of check-ins by device for each location:

```{r barplot-device-percent, fig.alt="Bar plot showing percent of check-ins at each location by device."}
percent_device %>%
  ggplot(aes(x = location, y = percent, fill = device)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Percentage of Check-ins by Device at Each Location",
       x = "Location",
       y = "Percentage")
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Exercise

Create a bar plot showing the proportion of check-ins by hour for each device.
Which hours had the highest proportion of check-ins from each device?

:::::::::::::::  solution

## Solution

```{r barplot-device-hour, fig.alt="Bar plot showing proportion of check-ins by hour for each device."}
# Calculate percentage of check-ins by hour and device
percent_hour_device <- sample_n(checkins, 500) %>%
  count(checkin_hour, device) %>%
  group_by(checkin_hour) %>%
  mutate(percent = (n / sum(n)) * 100) %>%
  ungroup()

# Create the plot
percent_hour_device %>%
  ggplot(aes(x = checkin_hour, y = percent, fill = device)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Proportion of Check-ins by Hour for Each Device",
       x = "Hour of Day",
       y = "Percentage")
```

From this plot, we can identify which hours had the highest proportion of check-ins from each device.

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

## Faceting

Rather than creating a single plot with side-by-side bars for each
hour, we may want to create multiple plots, where each plot shows the
data for a single device. This would be especially useful if we had
a large number of devices that we had sampled, as a large number of
side-by-side bars will become more difficult to read.

**`ggplot2`** has a special technique called *faceting* that allows the
user to split one plot into multiple plots based on a factor included
in the dataset. Let's use it to split our check-in counts by hour for each device:

```{r facet-fix, fig.alt="Fixed multi-panel line plot showing check-ins by hour for each device."}
# Create hourly counts by device
hourly_by_device <- sample_n(checkins, 500) %>%
  count(checkin_hour, device)

# Create the faceted plot with explicit group aesthetic
hourly_by_device %>%
  ggplot(aes(x = checkin_hour, y = n, group = device)) +  # Add group aesthetic
  geom_line() +
  geom_point() +
  labs(title = "Check-ins by Hour for Each Device",
       x = "Hour of Day",
       y = "Count") +
  facet_wrap(~ device)
```

Click the "Zoom" button in your RStudio plots pane to view a larger
version of this plot.

Usually plots with white background look more readable when printed. We can set
the background to white using the function `theme_bw()`. Additionally, we can remove
the grid:

```{r facet-theme-bw, fig.alt="Multi-panel line plot showing check-ins by hour for each device with clean black and white theme.", purl=FALSE}
hourly_by_device %>%
  ggplot(aes(x = checkin_hour, y = n)) +
  geom_line() +
  geom_point() +
  labs(title = "Check-ins by Hour for Each Device",
       x = "Hour of Day",
       y = "Count") +
  facet_wrap(~ device) +
  theme_bw() +
  theme(panel.grid = element_blank())
```

We can also facet by both location and device to see patterns across both variables:

```{r facet-location-device-fixed, fig.alt="Fixed multi-panel point plot showing check-in patterns by hour for each location and device combination."}
# Count check-ins by hour, location, and device
hourly_by_loc_device <- sample_n(checkins, 500) %>%
  count(checkin_hour, location, device)

# Create the faceted plot - fixing the filter issue
hourly_by_loc_device %>%
  # First filter the data
  filter(device %in% c("DEVICE_001", "DEVICE_002")) %>%
  # Then create the plot
  ggplot(aes(x = checkin_hour, y = n, group = device)) +
  geom_point() +
  geom_line() +
  labs(title = "Check-ins by Hour for Each Location and Device",
       x = "Hour of Day",
       y = "Count") +
  facet_wrap(~ location + device) +
  theme_bw() +
  theme(panel.grid = element_blank())
```

## Visualizing Location Data with Maps

When working with location data, it's often useful to visualize it on a map. While our dataset has anonymized locations, I'll demonstrate how to work with spatial data in ggplot2 using a hypothetical example.

To work with maps in ggplot2, we typically use additional packages:

```{r load-map-packages, eval=FALSE}
library(sf)      # For working with spatial data
library(ggmap)   # For background maps
library(maps)    # For map data
```

### Basic Map with Points

Let's create a hypothetical scenario where we have latitude and longitude for our locations. First, we'll create some fake coordinates for demonstration:

```{r create-fake-coordinates, eval=FALSE}
# Create a hypothetical dataset with coordinates
#(This is just for demonstration - your real data would have actual coordinates)
location_coords <- tibble(
  location = c("LOCATION_001", "LOCATION_002", "LOCATION_003"),
  lat = c(40.7128, 41.8781, 34.0522),
  lon = c(-74.0060, -87.6298, -118.2437)
)

# Join with our check-in data to get coordinates
checkins_with_coords <- sample_n(checkins, 500) %>%
  left_join(location_coords, by = "location")

# Count check-ins by location
location_counts <- checkins_with_coords %>%
  count(location, lat, lon)
```

Now we can create a basic map with points representing each location:

```{r basic-map, eval=FALSE}
# Get base map (this requires a Google API key in practice)
# usa_map <- get_map(location = "united states", zoom = 4, maptype = "terrain")

# For demonstration, we'll use a built-in US map
us_map <- map_data("usa")

# Create the map
ggplot() +
  geom_polygon(data = us_map, aes(x = long, y = lat, group = group),
               fill = "white", color = "black") +
  geom_point(data = location_counts,
             aes(x = lon, y = lat, size = n, color = location),
             alpha = 0.7) +
  scale_size_continuous(name = "Number of Check-ins") +
  coord_fixed(1.3) +
  labs(title = "Check-in Locations and Frequencies",
       x = "Longitude",
       y = "Latitude") +
  theme_minimal()
```

### Working with Shapefile Data

If you have precinct boundaries in a shapefile format, you can use the `sf` package to load and visualize them:

```{r sf-example, eval=FALSE}
# Load shapefile (in practice, replace with your actual file path)
# precincts <- st_read("path/to/your/precincts.shp")

# Create synthetic precinct data for demonstration
precincts <- tibble(
  precinct = unique(checkins$precinct),
  geometry = list(
    # These would be actual polygon coordinates in real data
    "POLYGON((-74.01 40.71, -74.02 40.71, -74.02 40.72, -74.01 40.72))"
  )
) %>%
  st_as_sf(wkt = "geometry", crs = 4326)

# Join with check-in counts
precinct_counts <- sample_n(checkins, 500) %>%
  count(precinct) %>%
  left_join(precincts, by = "precinct")

# Plot the map with filled precincts
ggplot() +
  geom_sf(data = precinct_counts, aes(fill = n), color = "white") +
  scale_fill_viridis_c(name = "Number of Check-ins") +
  labs(title = "Check-in Counts by Precinct",
       caption = "Darker colors indicate more check-ins") +
  theme_minimal()
```

### Creating a Heatmap

Another useful visualization is a heatmap showing check-in density:

```{r heatmap, eval=FALSE}
ggplot() +
  geom_polygon(data = us_map, aes(x = long, y = lat, group = group),
               fill = "white", color = "black") +
  stat_density_2d(data = checkins_with_coords,
                  aes(x = lon, y = lat, fill = stat(density)),
                  geom = "tile", contour = FALSE, alpha = 0.7) +
  scale_fill_viridis_c() +
  coord_fixed(1.3) +
  labs(title = "Check-in Density Heatmap",
       x = "Longitude",
       y = "Latitude") +
  theme_minimal()
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Exercise

Experiment with at least two different themes for your check-in visualizations. 
Which do you like best for presenting your time-series data?

::::::::::::::::::::::::::::::::::::::::::::::::::

## Customization

Take a look at the [**`ggplot2`** cheat
sheet](https://github.com/rstudio/cheatsheets/blob/main/data-visualization-2.1.pdf),
and think of ways you could improve the plot.

Let's create a custom theme for our check-in time visualization:

```{r ggplot-customization, purl=FALSE}
hourly_data %>%
  ggplot(aes(x = checkin_hour, y = n)) +
  geom_line(size = 1, color = "steelblue") +
  geom_point(size = 3, color = "steelblue") +
  labs(title = "Check-ins by Hour of Day",
       subtitle = "Analysis of temporal check-in patterns",
       caption = "Data source: anonymized_data.csv",
       x = "Hour of Day (24-hour format)",
       y = "Number of Check-ins") +
  theme_bw()
```

The axes have names, but their readability can be improved by
increasing the font size:

```{r ggplot-customization-font-size, purl=FALSE}
hourly_data %>%
  ggplot(aes(x = checkin_hour, y = n)) +
  geom_line(size = 1, color = "steelblue") + 
  geom_point(size = 3, color = "steelblue") +
  labs(title = "Check-ins by Hour of Day",
       subtitle = "Analysis of temporal check-in patterns",
       caption = "Data source: anonymized_data.csv",
       x = "Hour of Day (24-hour format)",
       y = "Number of Check-ins") +
  theme_bw() +
  theme(text = element_text(size = 16))
```

Note that it is also possible to change the fonts of your plots. If you are on
Windows, you may have to install the [**`extrafont`**
package](https://github.com/wch/extrafont), and follow the instructions included
in the README for this package.

We can add more customizations to improve the appearance of our plot:

```{r ggplot-customization-advanced, fig.alt="Highly customized time series plot of check-ins by hour with professional styling.", purl=FALSE}
hourly_data %>%
  ggplot(aes(x = checkin_hour, y = n)) +
  geom_line(size = 1.2, color = "steelblue") + 
  geom_point(size = 4, color = "steelblue", alpha = 0.7) +
  scale_x_continuous(breaks = 0:23) +  # Show all hours
  labs(title = "Check-in Patterns Throughout the Day",
       subtitle = "Analysis of temporal check-in patterns",
       caption = "Data source: anonymized_data.csv",
       x = "Hour of Day (24-hour format)",
       y = "Number of Check-ins") +
  theme_bw() +
  theme(
    text = element_text(size = 14, family = "Arial"),
    plot.title = element_text(size = 20, face = "bold", hjust = 0.5),
    plot.subtitle = element_text(size = 16, hjust = 0.5, color = "grey40"),
    axis.title = element_text(face = "bold"),
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_blank(),
    panel.border = element_rect(color = "grey70")
  )
```

If you like the changes you created better than the default theme, you can save
them as an object to be able to easily apply them to other plots you may create:

```{r ggplot-custom-themes, purl=FALSE}
my_theme <- theme(
  text = element_text(size = 14, family = "Arial"),
  plot.title = element_text(size = 20, face = "bold", hjust = 0.5),
  plot.subtitle = element_text(size = 16, hjust = 0.5, color = "grey40"),
  axis.title = element_text(face = "bold"),
  panel.grid.minor = element_blank(),
  panel.grid.major.x = element_blank(),
  panel.border = element_rect(color = "grey70")
)

hourly_by_device %>%
  ggplot(aes(x = checkin_hour, y = n, color = device)) +
  geom_line(size = 1) +
  geom_point(size = 2) +
  scale_x_continuous(breaks = 0:23, limits = c(0, 23)) +
  labs(title = "Check-in Patterns by Device",
       subtitle = "Hourly check-in activity",
       x = "Hour of Day",
       y = "Number of Check-ins") +
  theme_bw() +
  my_theme
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Exercise

With all of this information in hand, please take another five minutes to
either improve one of the plots generated in this exercise or create a
beautiful graph of your own using the check-in data. Use the RStudio [**`ggplot2`** cheat sheet](https://github.com/rstudio/cheatsheets/blob/main/data-visualization-2.1.pdf)
for inspiration. Here are some ideas:

- Create a heatmap showing check-in activity by hour and location.
- Make a line plot showing the cumulative number of check-ins over the course of the day.
- Try using a different colour palette for your device comparison.

::::::::::::::::::::::::::::::::::::::::::::::::::

After creating your plot, you can save it to a file in your favourite format. The Export tab in the **Plot** pane in RStudio will save your plots at low resolution, which will not be accepted by many journals and will not scale well for posters.

Instead, use the `ggsave()` function, which allows you to easily change the dimension and resolution of your plot by adjusting the appropriate arguments (`width`, `height` and `dpi`).

Make sure you have the `fig_output/` folder in your working directory.

```{r ggsave-example, eval=FALSE, purl=FALSE}
my_plot <- hourly_data %>%
  ggplot(aes(x = checkin_hour, y = n)) +
  geom_line(size = 1.2, color = "steelblue") +
  geom_point(size = 4, color = "steelblue", alpha = 0.7) +
  scale_x_continuous(breaks = 0:23) +  # Show all hours
  labs(title = "Check-in Patterns Throughout the Day",
       subtitle = "Analysis of temporal check-in patterns",
       caption = "Data source: anonymized_data.csv",
       x = "Hour of Day (24-hour format)",
       y = "Number of Check-ins") +
  theme_bw() +
  theme(
    text = element_text(size = 14, family = "Arial"),
    plot.title = element_text(size = 20, face = "bold", hjust = 0.5),
    plot.subtitle = element_text(size = 16, hjust = 0.5, color = "grey40"),
    axis.title = element_text(face = "bold"),
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_blank(),
    panel.border = element_rect(color = "grey70")
  )

ggsave("fig_output/checkin_patterns.png", my_plot, width = 10, height = 6, dpi = 300)
```

## Time-Based Analysis with Histograms and Time Buckets

When working with election data, understanding the distribution of check-ins over time is crucial. Let's create some specialized time-based visualizations to better understand this data.

First, let's create histograms to show the distribution of check-ins across the day:

```{r histogram-hours, fig.alt="Histogram showing the distribution of check-ins by hour."}
sample_n(checkins, 500) %>%
  ggplot(aes(x = checkin_hour)) +
  geom_histogram(binwidth = 1, fill = "skyblue", color = "black") +
  labs(title = "Distribution of Check-ins by Hour",
       x = "Hour of Day (24-hour format)",
       y = "Number of Check-ins") +
  theme_bw()
```

We can also create a more granular view by using smaller bins:

```{r histogram-time-bins, fig.alt="Histogram showing check-ins in 15-minute intervals."}
# Create a decimal representation of time (hour + minute/60)
checkins_with_decimal_hour <- sample_n(checkins, 500) %>%
  mutate(decimal_hour = checkin_hour + checkin_minute/60)

# Plot with 15-minute bins (0.25 hour)
checkins_with_decimal_hour %>%
  ggplot(aes(x = decimal_hour)) +
  geom_histogram(binwidth = 0.25, fill = "skyblue", color = "black") +
  scale_x_continuous(breaks = 0:23) +
  labs(title = "Check-ins in 15-minute Intervals",
       x = "Hour of Day",
       y = "Number of Check-ins") +
  theme_bw()
```

We can create time buckets to analyze check-in patterns during specific parts of the day:

```{r time-periods, fig.alt="Bar chart showing check-ins by time period of day."}
# Create time periods
checkins_with_periods <- sample_n(checkins, 500) %>%
  mutate(time_period = case_when(
    checkin_hour < 9 ~ "Early Morning (before 9am)",
    checkin_hour >= 9 & checkin_hour < 12 ~ "Morning (9am-12pm)",
    checkin_hour >= 12 & checkin_hour < 17 ~ "Afternoon (12-5pm)",
    checkin_hour >= 17 & checkin_hour < 20 ~ "Evening (5-8pm)",
    TRUE ~ "Night (after 8pm)"
  ))

# Order the factor levels
checkins_with_periods$time_period <- factor(
  checkins_with_periods$time_period,
  levels = c("Early Morning (before 9am)", 
             "Morning (9am-12pm)", 
             "Afternoon (12-5pm)", 
             "Evening (5-8pm)", 
             "Night (after 8pm)")
)

# Create the plot
checkins_with_periods %>%
  ggplot(aes(x = time_period)) +
  geom_bar(fill = "steelblue") +
  labs(title = "Check-ins by Time Period",
       x = "Time of Day",
       y = "Number of Check-ins") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

We can also visualize the hourly check-in rate, which is useful for polling station management:

```{r checkin-rate, fig.alt="Line graph showing check-ins per hour rate."}
# Calculate check-ins per hour by location
hourly_rate <- sample_n(checkins, 500) %>%
  count(location, checkin_hour) %>%
  rename(checkins_per_hour = n)

# Plot the hourly rate
hourly_rate %>%
  ggplot(aes(x = checkin_hour, y = checkins_per_hour, color = location)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  labs(title = "Hourly Check-in Rate by Location",
       subtitle = "Helps identify peak hours and staffing needs",
       x = "Hour of Day",
       y = "Check-ins per Hour") +
  theme_bw() +
  theme(legend.position = "bottom")
```

Let's examine the cumulative check-ins to see how voting activity accumulates throughout the day:

```{r cumulative-checkins, fig.alt="Cumulative line graph showing total check-ins over time."}
# Calculate cumulative check-ins by hour
cumulative_checkins <- sample_n(checkins, 500) %>%
  count(checkin_hour) %>%
  arrange(checkin_hour) %>%
  mutate(cumulative = cumsum(n))

# Create the cumulative plot
cumulative_sample_n(checkins, 500) %>%
  ggplot(aes(x = checkin_hour, y = cumulative)) +
  geom_line(size = 1.2, color = "darkblue") +
  geom_point(size = 3, color = "darkblue") +
  scale_x_continuous(breaks = seq(0, 23, by = 2)) +
  labs(title = "Cumulative Check-ins Throughout the Day",
       subtitle = "Shows the accumulation of voters over time",
       x = "Hour of Day",
       y = "Total Check-ins") +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```

Finally, let's compare the check-in patterns across different locations with a heatmap:

```{r location-hour-heatmap, fig.alt="Heatmap showing check-in density by hour and location."}
# Create hour-location count data
hour_location_counts <- sample_n(checkins, 500) %>%
  count(location, checkin_hour)

# Create the heatmap
hour_location_counts %>%
  ggplot(aes(x = checkin_hour, y = location, fill = n)) +
  geom_tile() +
  scale_fill_viridis_c(name = "Number of\nCheck-ins") +
  scale_x_continuous(breaks = 0:23) +
  labs(title = "Check-in Density by Hour and Location",
       subtitle = "Darker colors indicate more check-ins",
       x = "Hour of Day",
       y = "Location") +
  theme_bw() +
  theme(panel.grid = element_blank(),
        legend.position = "right")
```

:::::::::::::::::::::::::::::::::::::::  challenge

## Exercise

Using the time period categories we created (`time_period`), create a stacked bar chart that shows the proportion of check-ins by device during each time period.

:::::::::::::::  solution

## Solution

```{r time-period-device, fig.alt="Stacked bar chart showing proportion of devices used during each time period."}
# Calculate counts and percentages
period_device_counts <- checkins_with_periods %>%
  count(time_period, device) %>%
  group_by(time_period) %>%
  mutate(percentage = n / sum(n) * 100) %>%
  ungroup()

# Create the stacked bar chart
period_device_counts %>%
  ggplot(aes(x = time_period, y = percentage, fill = device)) +
  geom_bar(stat = "identity", position = "stack") +
  labs(title = "Proportion of Devices Used During Each Time Period",
       x = "Time of Day",
       y = "Percentage of Check-ins",
       fill = "Device") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

This visualization shows which devices were most active during different parts of the day, which could be useful for optimizing device deployment in future elections.

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::: keypoints

- `ggplot2` is a flexible and useful tool for creating plots in R.
- The data set and coordinate system can be defined using the `ggplot` function.
- Additional layers, including geoms, are added using the `+` operator.
- Time-series data can be visualized using `geom_line()` and `geom_point()`.
- Boxplots are useful for visualizing the distribution of check-in times by location.
- Barplots are useful for visualizing counts of check-ins by categorical variables.
- Faceting allows you to generate multiple plots based on a categorical variable like device.
- Spatial data can be visualized on maps using packages like `sf`, `ggmap`, and `maps`.

::::::::::::::::::::::::::::::::::::::::::::::::::


